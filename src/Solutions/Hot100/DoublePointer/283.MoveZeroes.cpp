#include <iostream>
#include <vector>

/// 本道题中，要在不使用额外空间的情况下将所有0移至末尾，并保持数组的原顺序
/// 无额外空间，就容易想到这是一个数组元素的交换问题，双指针就是个可能的解法
/// 那么，本道题和对称性无关，从后遍历无意义，故联想到快慢指针
/// 因为是交换，所以每次都交换快指针和慢指针上的元素即可
/// 交换的是什么？容易想到是0和其他元素
/// 快指针遍历时跳过0；慢指针遍历时找0
/// 若快指针向前遍历时遇到非0元素，就将慢指针指向的0元素和快指针指向的非0元素交换
/// 算法的正确性如何保证？因为快指针会按原相对顺序遍历到每一个非0元素，且每次遇到非0元素都会和较靠前的0交换
/// 所以可以保证快指针遍历完毕后，数组中的最后n个元素(n为0的数量)要么（非0 && 和0交换过），要么 本身就是0
/// 时间复杂度O(n)，空间复杂度O(n)
/// 实现时，注意优先处理慢指针当前为0，或当前不为0且下一个为0的情况
/// 若当前为0:不更新慢指针
/// 若当前不为0且下一个为0：慢指针后移
/// 实现时注意：
/// 1. 要特判慢指针还未找到0的情况，把慢指针初始化为-1即可，找到0了再交换

using namespace std;

void Solve(vector<int>& nums);
void Solve2(vector<int>& nums);
void Solve3(vector<int>& nums);


int main()
{
    int n; cin >> n;
    vector <int> nums;

    for (int i = 0; i < n; ++i)
    {
        int num; cin >> num;
        nums.push_back(num);
    }

    Solve(nums);

    for (auto num: nums)
    {
        cout << num << " ";
    }

}

void Solve(vector<int>& nums)
{
    int slowP = -1;
    int fastP = 0;

    int n = nums.size();

    for (; fastP < n; ++fastP)
    {
        // 快指针遇到0，且slowP还从未更新
        if (nums[fastP] == 0 && slowP == -1) 
        {
            slowP = fastP;
            continue;
        }
        
        // 若当前慢指针为0，什么也不做，等待交换

        // 若下一个是0且当前不是0，更新为下一个
        if (slowP != -1 && nums[slowP + 1] == 0 && nums[slowP] != 0)
        {
            slowP++;
        }

        // 慢指针还未找到0，直接跳过
        if (slowP == -1) continue;

        // 快指针遇到非0
        nums[slowP] = nums[fastP];
        nums[fastP] = 0;
    }
}

// 5
// 0 1 0 3 12

/// 逻辑优化版（个人认为非常不直观）
/// 慢指针不记录0的位置，而是记录“要插入的最后一个非0元素的位置”
/// 非0位置的初始位置为0，若该位置非0则自交换，不影响结果
/// 之后快指针不断向后遍历，一旦遇到非0元素就和慢指针位置交换，并让慢指针后移
/// 那么问题来了，这个算法的正确性如何保证呢？
/// 再来看题目要求：数组中元素的相对顺序被保证，同时所有0移动至末尾
/// 在遍历的过程当中，快指针会跳过所有的0，这首先保证不会有0被交换到前面
/// 那么剩下的可能错误点也就是否会有两个非0元素交换，导致顺序被打乱
/// 我们不妨来构造一个例子，如果一个数组全部都是非0元素，即 4 2 3 1
/// 此时快慢指针会齐头并进，不断与自身交换，没问题；
/// 假如往中间添加一个0，即4 0 2 3 1
/// 此时快慢指针同时来到0时，快指针会继续向前，而慢指针则停留在0，这个停留是关键
/// 也就是说，在if (nums[i] != 0) lastNonZeroPos++;这里，我们实际上确保了慢指针总会停留在0位置，等待后面的元素和该0交换
/// 等同于隐式的if (nums[i] == 0) lastNonZeroPos不动
/// 并且，此时快指针向后移动后，将其之后的一个元素和0交换，慢指针下一次移动正好移动到了0上，从而开始下一次流程的重复，这个点也是关键
/// 如果遇到了0连坐，那么快指针就会一直移动到连续0后的第一个元素，再由慢指针遍历这些0进行交换
/// 也就是说，在第一次遇到0之前，快慢指针同步更新，在第一次遇到0之后，其实慢指针每次移动都会遇到0元素并和快指针上的非0元素交换
/// 这个“每次移动都会遇到0元素”也是被隐式确保的，根据我们上面的分析可以得到
/// 至此，正确性就证明完毕了
/// 可以看到，这个写法充满了隐式的确保，所以我个人认为非常不直观，但是由于写法简洁得到推崇
/// 时间复杂度O(n)，空间复杂度O(1)

void Solve2(vector<int>& nums) 
{
    int lastNonZeroPos = 0;  // 当前最后一个非0元素的位置
    int n = nums.size();
    
    for (int i = 0; i < n; i++) 
    {
        if (nums[i] != 0) 
        {
            swap(nums[lastNonZeroPos], nums[i]);
            lastNonZeroPos++;
        }
    }
}

/// 接下来也是一种直观的写法，且思路非常直接，个人认为比我想的第一种好，也比第二个不直观的写法好
/// 由于整个数组，可以划分为两派，要么0，要么非0
/// 于是我们可以这样想，只要找到所有的非0元素放在前面，那么剩下的要么没0，要么全是0，就填充在数组的末尾就行
/// 这种写法的时间复杂度也是O(n)，且逻辑一看就懂
/// 空间复杂度O(1)
/// 实现时注意：数组只有一个0的特判，curNonZeroPos会变成-1导致边界错误
/// 干脆数量 <=1 就不需要任何操作，直接返回就行

void Solve3(vector<int>& nums) 
{
    int curNonZeroPos = 0;
    int n = nums.size();

    if (n <= 1) return;

    for (int i = 0; i < n; i++)
    {
        if (nums[i] != 0)
        {
            nums[curNonZeroPos++] = nums[i];
        }
    }

    for (int i = curNonZeroPos; i < n; i++)
    {
        nums[i] = 0;
    }

}
