#include <vector>
#include <iostream>

/// 本道题中，要对一个二维矩阵进行处理：对于有0的行和列，将整行和整列置0
/// 很容易想到，如果直接遇0就处理的话，在之后的遍历中可能会遇到原本非0但被置0的位置，导致额外的行或列被置0
/// 于是要对矩阵进行预处理，先标记一次有0的行或列，再在第二次遍历中真正置0
/// 容易想到使用额外空间，如哈希表或数组来存储列“是否有0”的状态，但是O(m + n)级别的空间复杂度，而题目要求原地算法
/// 于是思考：如何在使用常数空间的情况下标记行或列的状态
/// 使用常数空间，也就是说要利用矩阵本身的空间
/// 整个矩阵其实就两种数，非0数和0
/// 对于某一行或列，我们可以规定一个特殊的规则标记位，若该行或列有0就把它置0
/// 那么对于该位置，若本来就为0，无影响
/// 若非0，则因为其所在行或列有0，它本来就是要被置0的数，置0也不影响，不丢失信息
/// 于是，通过这样一个矩阵内部的特殊标记位，就成功标记了该行或列的状态
/// 那么这个标记位选在哪呢？当然是矩阵的第0行和第0列最合适
/// 对于第0行的第j个元素和第0列的第i个元素，就标记了第i行和第j列是否有0，即是否需要把整行/列置0
/// 访问到有0的元素时，设位置为(a, b)，则将matrix[0][b]（第0行的第b个）和matrix[a][0]（第0列的第a个）置0
/// 再在第二次遍历中只看第0行/列的标记情况，并将相应的整行/列置0即可
/// 实现时注意：
    //  1. 对于第0行和第0列，还需要两个标记位标记这两个特殊的行/列是否有0
    /// 因为用这两行/列做标记的话，那么它们本身的信息就无法被记录了
    /// 用两个bool标记，空间复杂度还是常数级别
    /// 2. 遍历次数比较多，先遍历一遍第0行/列标记，再遍历整个矩阵标记，再遍历一遍第0行/列来处理整个矩阵，最后处理利用两个bool处理第0行/列
    /// 但整体时间复杂度还是O(m * n)
    /// 3. 第二次遍历矩阵时，“再遍历一遍第0行/列来处理整个矩阵”的过程也有先行后列的顺序，会导致额外的行/列被置0，所以要跳过第0行/列，从1开始遍历
    /// 第0行/列已经被置过0，所以最后由两个bool标记单独处理就行

using namespace std;

void Solve(vector<vector<int>>& matrix, int n, int m);

int main()
{
    vector<vector<int>> matrix(100, vector<int>(100, 0));

    int n, m; cin >> n >> m;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
        {
            cin >> matrix[i][j];
        }

    Solve(matrix, n, m);

    for (int i = 0; i < n; ++i)
    {  
        for (int j = 0; j < m; ++j)
        {
            cout << matrix[i][j] << " ";
        }
        
        cout << endl;
    }

}

void Solve(vector<vector<int>>& matrix, int n, int m)
{
    // 记录第0行/列信息，注意行是横着的，列是竖着的
    bool Row0Has0 = false;
    bool Col0Has0 = false;

    // 第0行，对应j遍历
    for (int j = 0; j < m; ++j)
    {
        if (matrix[0][j] == 0)
        {
            Row0Has0 = true;
        }
    }

    // 第0列，对应i遍历
    for (int i = 0; i < n; ++i) 
    {
        if (matrix[i][0] == 0)
        {
            Col0Has0 = true;
        }
    }

    // 记录矩阵信息
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
        {
            if (matrix[i][j] == 0)
            {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    
    // 先处理整个矩阵
    // 看第0行
    for (int j = 1; j < m; ++j) // j = 1开始，跳过第0列
    {
        if (matrix[0][j] == 0)
        {
            for (int i = 1; i < n; ++i) // i = 1开始，跳过第0行
            {
                matrix[i][j] = 0;
            }
        }
    }

    // 看第0列
    for (int i = 1; i < n; ++i) // i = 1开始，跳过第0行
    {
        if (matrix[i][0] == 0)
        {
            for (int j = 1; j < m; ++j) // j = 1开始，跳过第0列
            {
                matrix[i][j] = 0;
            }
        }
    }

    // 再处理第0行/列
    if (Row0Has0)
        for (int j = 0; j < m; j++)
            matrix[0][j] = 0;

    if (Col0Has0)
        for (int i = 0; i < n; i++)
            matrix[i][0] = 0;
}

// 3 3
// 0 1 1
// 1 0 1
// 1 1 1

